# -*- coding: utf-8 -*-
"""auto_growth's_computing_rate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hRAW55Am1NLweGrwvN1vXfAUwLAc6QEb
"""

# Commented out IPython magic to ensure Python compatibility.
#from google.colab import drive
#drive.mount('/content/drive')
# %cd /content/drive/My Drive/Raw_datasets

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import cv2
import numpy as np
from matplotlib import pyplot as plt
import matplotlib as mpl
mpl.rcParams['figure.dpi'] = 150         # set the dpi of inline figure

def imshow(img, title="", axis=False):
    _, _, *chs = img.shape
    if not chs:
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_GRAY2RGB), interpolation='nearest')
    else:
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB), interpolation='nearest')
    plt.title(title)
    if axis == False:
        plt.axis("off")
    plt.show()

def count(img):
  n_white_pix = np.sum(img == 255)
  #n_white_pix = np.sum(img != 255)
  return n_white_pix

def find_mask(img):
  # edge detection
  gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  gray_img = cv2.GaussianBlur(gray_img, (9,9), 0)
  _, mask_img = cv2.threshold(gray_img, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)
  return mask_img

def region(img, back, mask):
  img[back != 0] = 0
  img[mask == 0] = 255
  return img

### START HERE ###

"""#test"""
# read from seg folder
img_color = cv2.imread("10/10_82.png", cv2.IMREAD_COLOR)
imshow(img_color, "color image")

width = img_color.shape[0]
height = img_color.shape[1]
img_no_boundary = np.array(img_color)
img_no_boundary = img_no_boundary[int(width*.1):int(width*.9),int(height*.1):int(height*.9)]
imshow(img_no_boundary, "color image")

mask = find_mask(img_no_boundary)
imshow(mask, "Mask")

# calculate histogram from hue and saturation channels
h_bins = 30
s_bins = 30
histSize = [h_bins, s_bins]
h_ranges = [0, 60]
s_ranges = [0, 60]
ranges = h_ranges + s_ranges
channels = [0, 1]

hsv_img = cv2.cvtColor(img_no_boundary, cv2.COLOR_BGR2HSV)

hist = None
hist = cv2.calcHist(cv2.split(hsv_img), channels, mask, histSize, ranges, accumulate=False)

# test histogram
'''
plt.imshow(hist)
plt.title("Histogram of leaves' color")
plt.xlabel("Saturation")
plt.ylabel("Hue")
plt.show()
'''

# histogram back-projection
backproj_img = cv2.calcBackProject(cv2.split(hsv_img), channels, hist, ranges, scale=1)
# post-processing using morphological filters => remove noise
structuring_elem = np.ones((3,3),np.uint8)
backproj_img = cv2.morphologyEx(backproj_img, cv2.MORPH_CLOSE, structuring_elem, iterations=20)
backproj_img = cv2.morphologyEx(backproj_img, cv2.MORPH_OPEN, structuring_elem, iterations=20)

region = region(img_no_boundary, backproj_img, mask)
imshow(region, "region")

n_white_pix = count(region)
print(n_white_pix)
print('growth: {0:.2f}%'.format(n_white_pix*100 / 40000))

"""#Function"""

h_bins = 30
s_bins = 30
histSize = [h_bins, s_bins]
h_ranges = [0, 180]
s_ranges = [0, 255]
ranges = h_ranges + s_ranges
channels = [0, 1]
structuring_elem = np.ones((3,3),np.uint8)

def back_projection(input_img, mask):
  hsv_img = cv2.cvtColor(input_img, cv2.COLOR_BGR2HSV)

  hist = cv2.calcHist(cv2.split(hsv_img), channels, mask, histSize, ranges, accumulate=False)

  backproj_img = cv2.calcBackProject(cv2.split(hsv_img), channels, hist, ranges, scale=1)  ##ERROR?
  #imshow(backproj_img, "image")
  backproj_img = cv2.morphologyEx(backproj_img, cv2.MORPH_CLOSE, structuring_elem, iterations=20)
  backproj_img = cv2.morphologyEx(backproj_img, cv2.MORPH_OPEN, structuring_elem, iterations=20)
  return backproj_img

#plt.figure(figsize=(300,300))
#plt.subplots_adjust(right = 0.3, top = 0.99, wspace = 0.1, hspace=0.3)

growth_max = 5000
def compute(n):
  data = []
  for i in range(n):
    # READ IMAGE
    if i in [0, 5, 30, 35]:
      data.append(0)
      continue
    image_name = '10/10_' + str(i+1) + '.png'
    img_color = cv2.imread(image_name, cv2.IMREAD_COLOR)
    # post processing
    width = img_color.shape[0]
    height = img_color.shape[1] 
    img_no_boundary = np.array(img_color)
    if i < 7:
      img_no_boundary = img_no_boundary[:int(width*.9),int(height*.1):int(height*.9)]
    elif i >= 7 and i < 98:
      img_no_boundary = img_no_boundary[int(width*.1):int(width*.9),int(height*.1):int(height*.9)]
    elif i >= 98:
      img_no_boundary = img_no_boundary[int(width*.1):,int(height*.1):int(height*.9)]

    viz = np.array(img_no_boundary)

    mask = find_mask(img_no_boundary)
    backproj_img = back_projection(img_no_boundary, mask)
    #region = region(img_no_boundary, backproj_img, mask)
    img_no_boundary[backproj_img != 0] = 0
    img_no_boundary[mask == 0] = 255
    n_white_pix = count(img_no_boundary)

    rate = n_white_pix*100 / growth_max
    data.append(rate)
    growth_rate = '{0:.2f}%'.format(rate)

    '''
    mask = find_mask(img_no_boundary)
    hsv_img = cv2.cvtColor(img_no_boundary, cv2.COLOR_BGR2HSV)
    hist = cv2.calcHist(cv2.split(hsv_img), channels, mask, histSize, ranges, accumulate=False)
    backproj_img = cv2.calcBackProject(cv2.split(hsv_img), channels, hist, ranges, scale=1)
    structuring_elem = np.ones((5,5),np.uint8)
    backproj_img = cv2.morphologyEx(backproj_img, cv2.MORPH_CLOSE, structuring_elem, iterations=3)
    backproj_img = cv2.morphologyEx(backproj_img, cv2.MORPH_OPEN, structuring_elem, iterations=3)
    #region = region(img_color, backproj_img, mask)
    img_no_boundary[backproj_img != 0] = 0
    img_no_boundary[mask == 0] = 255
    n_white_pix = count(img_no_boundary)
    growth_rate = '{0:.2f}%'.format(n_white_pix*100 / 7000)
    '''
    '''
    plt.subplot(n,5,i+1)
    #plt.imshow(cv2.cvtColor(mask, cv2.IMREAD_GRAYSCALE), interpolation='nearest')
    #plt.imshow(cv2.cvtColor(viz, cv2.COLOR_BGR2RGB), interpolation='nearest')
    plt.imshow(cv2.cvtColor(img_no_boundary, cv2.IMREAD_GRAYSCALE), interpolation='nearest')
    #color = "green" if predicted_ids[n] == true_label_ids[i] else "red"

    if n_white_pix / growth_max > 1.2:
      plt.title('system error')
    elif n_white_pix / growth_max > 1.0 and n_white_pix / growth_max <= 1.2:
      plt.title('Available')
    else:
      plt.title(growth_rate)
    plt.axis('off')
    '''
  return np.array(data)

"""# save value"""

growths = compute(36)
growths

growths = growths.reshape(6,6)
growths.shape

#save for visualization
np.savetxt('10_04_2020.csv', growths, delimiter=',')